:PROPERTIES:
:ID:       86ac2451-8d29-4ef2-bddd-321efca9cac6
:ROAM_REFS: https://leetcode.com/problems/largest-rectangle-in-histogram/submissions/
:END:
#+title: 84. Largest Rectangle in Histogram
#+filetags: :Hard:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
Given an array of integers ~heights~ representing the histogram's bar height where the width of each bar is ~1~, return /the area of the largest rectangle in the histogram/.

*Example 1:*

[[https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg]]
#+BEGIN_SRC
Input: heights = [2,1,5,6,2,3]
Output: 10
Explanation: The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.
#+END_SRC

Example 2:

[[https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg]]
#+BEGIN_SRC
Input: heights = [2,4]
Output: 4
#+END_SRC

*Constraints:*

- ~1 <= heights.length <= 10^{5}~
- ~0 <= heights[i] <= 10^{4}~

* 思路
这题的思路首先是要了解其什么时候才应该计算面积, 以及什么如何计算面积.

对于正在上升的序列来说, 统计面积是不必要的, 因为下一次的面积必然会比现在大(宽度一直增加), 这时候只需要将现在的坐标记录到[[id:2140c8b6-c24e-4e28-98b9-199805b76bc4][栈]]中即可.

如果遇到了比其小的数, 就意味着上升序列结束, 需要计算以前的面积数据.

这就到了第二个问题: 如何计算面积. 首先, 对于栈中的每一个值来说, 其计算方式都是 ~高度 * 到当前位置的距离~, 这是因为栈中的数据都比前一个数据要大, 比后面的数据要小, 所以其有效宽度只能这样计算.

为了方便计算, 将已有数据的后面加上 -1, 来在最后再对栈中的所有数据进行判断

在栈前加上 -1, 来避免栈只有一个数据不好统计的情况.

* 代码
#+BEGIN_SRC go
func largestRectangleArea(heights []int) int {
    stack := []int{-1}
    heights = append(heights, -1)
    max := 0
    for i := 0; i < len(heights); i++ {
        for len(stack) > 1 && heights[stack[len(stack)-1]] >= heights[i] {
            top := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            cur := heights[top] * (i - stack[len(stack)-1] - 1)
            if cur > max { max = cur }
        }
        stack = append(stack, i)
    }
    return max
}
#+END_SRC
