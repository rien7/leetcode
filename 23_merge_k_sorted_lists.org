:PROPERTIES:
:ID:       fecc5a3d-f458-4e6a-8303-10de34de81da
:ROAM_REFS: https://leetcode.com/problems/merge-k-sorted-lists/submissions/
:END:
#+title: 23. Merge k Sorted Lists
#+filetags: :Hard:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
You are given an array of ~k~ linked-lists ~lists~, each linked-list is sorted in ascending order.

/Merge all the linked-lists into one sorted linked-list and return it./

*Example 1:*

#+BEGIN_SRC
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: lists = []
Output: []
#+END_SRC

Example 3:

#+BEGIN_SRC
Input: lists = [[]]
Output: []
#+END_SRC

*Constraints:*

- ~k == lists.length~
- ~0 <= k <= 10^4~
- ~0 <= lists[i].length <= 500~
- ~-10^4 <= lists[i][j] <= 10^4~
- ~lists[i]~ is sorted in *ascending order*.
- The sum of ~lists[i].length~ won't exceed ~10^4~.

* 思路
本题有两种解法:

** 思路1
每次找[[id:2dac612c-48d9-4fe9-9d0b-c5421d26dff2][链表]]中的最小值. 这种方法的优点是简单明了, 缺点是每次找到一个最小值后都要重新遍历一次链表数组, 例如:
#+begin_src
Input: [[1,4,5],[1,3,4],[2,6]]
iter 0: [[1,4,5],[1,3,4],[2,6]] ==> 1, loop 3 times
iter 1: [[4,5],[1,3,4],[2,6]] ==> 1, loop 3 times
iter 2: [[4,5],[3,4],[2,6]] ==> 2, loop 3 times
iter 3: [[4,5],[3,4],[6]] ==> 3, loop 3 times
iter 4: [[4,5],[4],[6]] ==> 4, loop 3 times
iter 5: [[5],[4],[6]] ==> 4, loop 3 times
iter 6: [[5],[],[6]] ==> 5, loop 2 times
iter 7: [[],[],[6]] ==> 6, loop 1 time
#+end_src

一共循环了 21 次(最后几次的空链表跳过循环), 循环次数基本上为 ~k * n (k: len(lists), n: all nodes length)~

因此, 在 ~k~ 的值比较大的时候, 这种方法比较慢.

** 思路2
采用[[id:01ece1ef-46db-4bd6-88da-e2cb136a2395][分治]]的方法, 将多个链表的合并分解为两个链表的合并.

这里将整个链表分解成左右两个链表来解题, 如果左右两个链表都是基础链表(~len(lists) == 1~), 那么合并这两个链表.

合并的方式为也是一个个的进行大小判断.

* 代码
#+BEGIN_SRC go
/**
 ,* Definition for singly-linked list.
 ,* type ListNode struct {
 ,*     Val int
 ,*     Next *ListNode
 ,* }
 ,*/
// 思路1
func mergeKLists(lists []*ListNode) *ListNode {
    head := &ListNode{Val: -1}
    res := head
    for {
        curNum, curI := 10001, -1
        for i, node := range lists {
            if node == nil { continue }
            if node.Val < curNum {
                curNum = node.Val
                curI = i
            }
        }
        if curI == -1 { break }
        res.Next = lists[curI]
        res = res.Next
        lists[curI] = lists[curI].Next
    }
    return head.Next
}
// 思路2
func mergeKLists(lists []*ListNode) *ListNode {
    length := len(lists)
    if length == 0 { return nil }
    if length == 1 { return lists[0] }
    mid := length / 2
    left := mergeKLists(lists[:mid])
    right := mergeKLists(lists[mid:])
    return merge(left, right)
}
​
func merge(left, right *ListNode) *ListNode {
    if left == nil { return right }
    if right == nil { return left }
    if left.Val < right.Val {
        left.Next = merge(left.Next, right)
        return left
    } else {
        right.Next = merge(left, right.Next)
        return right
    }
}
#+END_SRC
