:PROPERTIES:
:ID:       3ae50826-8fe8-4d3e-9777-a4a848baf29c
:ROAM_REFS: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/
:END:
#+title: 452. Minimum Number of Arrows to Burst Balloons
#+filetags: :Medium:

* 问题
There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array ~points~ where ~points[i] = [x_{start}, x_{end}]~ denotes a balloon whose *horizontal diameter* stretches between ~x_{start}~ and ~x_{end}~. You do not know the exact y-coordinates of the balloons.

Arrows can be shot up *directly vertically* (in the positive y-direction) from different points along the x-axis. A balloon with ~x_{start}~ and ~x_{end}~ is *burst* by an arrow shot at ~x~ if ~x_{start} <= x <= x_{end}~. There is *no limit* to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the array ~points~, return /the *minimum* number of arrows that must be shot to burst all balloons/.

*Example 1:*

#+BEGIN_SRC
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.
#+END_SRC

Example 3:

#+BEGIN_SRC
Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].
#+END_SRC

*Constraints:*

- ~1 <= points.length <= 10^{5}~
- ~points[i].length == 2~
- ~-2^{31} <= x_{start} < x_{end} <= 2^{31} - 1~

* 思路
本题乍一看和 [[id:eb040d3a-e421-4acf-915e-07bdae0b625a][1094. Car Pooling]] 挺像, 都是在一段序列内判断"最大数量", 但实际上却截然不同:
1. 本题的序列不是连续单调的
2. 本题的判断最大的逻辑并不是判断每一个阶段的数量

** 思路1
本题的题意即判断最少重叠段, 并且重叠段不能重复(气球被击破了就不再计入)

为了方便遍历判断, 先将得到的二维数组进行排序. 这里使用的是 =sort.Sort()= 包, =Less()= 函数的实现方式为先判断起始位, 再判断结束位

随后记录重叠段(~point[0] <= end~), 这表明有重叠的部分, 这时候需要继续缩小重叠段的范围, 防止 ~[[1, 4], [1, 2], [3, 4]]~ 这种情况被记录成 1 次.

如果 ~point[0] > end~, 则说明上一重叠段已经结束, 对结果+=1, 并且重置重叠段的范围.

同时, 由于重叠段中, start 并不参与判断, 因此可以删除, 只留下 end.

* 代码
#+BEGIN_SRC go
type asc [][]int
​
func (p asc) Len() int {
    return len(p)
}
​
func (p asc) Swap(i, j int) {
    p[i], p[j] = p[j], p[i]
}
​
func (p asc) Less(i, j int) bool {
    return p[i][0] < p[j][0] || (p[i][0] == p[j][0] && p[i][1] < p[j][1])
}
​
func findMinArrowShots(points [][]int) int {
    sort.Sort(asc(points))
    res := 1
    end := points[0][1]
    for _, point := range points {
        if point[0] <= end {
            if point[1] < end { end = point[1] }
        } else {
            res++
            end = point[1]
        }
    }
    return res
}
#+END_SRC
