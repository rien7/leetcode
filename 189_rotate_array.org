:PROPERTIES:
:ID:       71f57abc-5e76-4816-9893-d7c820752709
:ROAM_REFS: https://leetcode.com/problems/rotate-array/
:END:
#+title: 189. Rotate Array
#+filetags: :Medium:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
Given an array, rotate the array to the right by ~k~ steps, where ~k~ is non-negative.

*Example 1:*

#+BEGIN_SRC
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
#+END_SRC

*Constraints:*

- ~1 <= nums.length <= 10^{5}~
- ~-2^{31} <= nums[i] <= 2^{31} - 1~
- ~0 <= k <= 10^{5}~

*Follow up:*

- Try to come up with as many solutions as you can. There are at least *three* different ways to solve this problem.
- Could you do it in-place with ~O(1)~ extra space?

* 思路
今天的题目比较的简单, 主要是要将"循环"处理好, 用余数获得真正要转移的数字即可.

还需要注意的是: =append= 在内存中是如何处理的, ~nums = append(nums[r:], nums[:r]...)~ 并行不通

* 代码
#+BEGIN_SRC go
func rotate(nums []int, k int)  {
    n := len(nums)
    r := n - (k % n)
    arr := append(nums[r:], nums[:r]...)
    copy(nums, arr)
}
#+END_SRC
