:PROPERTIES:
:ID:       f176ba28-4ec7-4221-8f8b-5ebcf207323e
:ROAM_REFS: https://leetcode.com/problems/stone-game-iv/submissions/ https://leetcode.com/problems/stone-game-iv/
:END:
#+title: 1510. Stone Game IV
#+filetags: :Hard:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
Alice and Bob take turns playing a game, with Alice starting first.

Initially, there are ~n~ stones in a pile. On each player's turn, that player makes a /move/ consisting of removing *any* non-zero *square number* of stones in the pile.

Also, if a player cannot make a move, he/she loses the game.

Given a positive integer ~n~, return ~true~ if and only if Alice wins the game otherwise return ~false~, assuming both players play optimally.

*Example 1:*

#+BEGIN_SRC
Input: n = 1
Output: true
Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves.
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: n = 2
Output: false
Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).
#+END_SRC

Example 3:

#+BEGIN_SRC
Input: n = 4
Output: true
Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).
#+END_SRC

*Constraints:*

- ~1 <= n <= 10^{5}~

* 思路
本题也是一道十分经典的[[id:a079d01f-7acf-4c34-bcbc-0fe0f71d09f7][动态规划]]的题目. 但怎么定义状态转移方程就是问题的核心. 和 [[id:ac0cd3fd-3c6a-46e7-b36b-71b1d9f2147a][1463. Cherry Pickup II]] 类似, 这种多个人的问题都需要转换成一个对象来做.

** 思路1
先从常规方式来看, 一个选手要赢, 那么看其移除 *平方数* 个石头后的结果是否能赢, 否则轮到下一个选手

** 思路2
思路1 会超时, 因此需要存储中间结果来加速, 这里的方案是 =dp[i]= 表示在还剩下 =i= 个石头的时候 Alice 是否能赢.

* 代码
#+BEGIN_SRC go
// 思路1
func winnerSquareGame(n int) bool {
    if n == 0 { return false }
    for i := 1; i*i <= n; i++ {
        // 另一个选手没赢, 那么自己就赢了
        if !winnerSquareGame(n-i*i) {
            return true
        }
    }
    return false
}
// 思路2
func winnerSquareGame(n int) bool {
    dp := make([]bool, n+1)
    for i := range dp {
        if dp[i] { continue }
        for j := 1; j*j+i <= n; j++ {
            dp[j*j+i] = true
        }
    }
    return dp[n]
}
#+END_SRC
