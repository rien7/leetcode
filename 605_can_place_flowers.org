:PROPERTIES:
:ID:       9c3e9fa2-4225-4315-b88f-742852bd5d95
:ROAM_REFS: https://leetcode.com/problems/can-place-flowers/submissions/
:END:
#+title: 605. Can Place Flowers
#+filetags: :Easy:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in *adjacent* plots.

Given an integer array ~flowerbed~ containing ~0~'s and ~1~'s, where ~0~ means empty and ~1~ means not empty, and an integer ~n~, return /if/ ~n~ new flowers can be planted in the ~flowerbed~ without violating the no-adjacent-flowers rule.

*Example 1:*

#+BEGIN_SRC
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
#+END_SRC

*Constraints:*

- ~1 <= flowerbed.length <= 2 * 10^{4}~
- ~flowerbed[i]~ is ~0~ or ~1~.
- There are no two adjacent flowers in ~flowerbed~.
- ~0 <= n <= flowerbed.length~

* 思路
本题有两种解题思路

** 思路1
[[id:1658b6c1-8bcf-4541-937a-0cf5a5b86862][849. Maximize Distance to Closest Person]], 和这题一样, 通过滑动窗口来做, 判断每个窗口可以种多少花.

并且为了方便计算, 还可以在两旁加上边界来减少对边界的判断

** 思路2
真实种花, 判断当前位置是否可以种花, 如果可以, 就种下.

* 代码
#+BEGIN_SRC go
// 思路1
func canPlaceFlowers(flowerbed []int, n int) bool {
    fill := append([]int{1,0}, append(flowerbed, 0, 1)...)
    sum := 1
    left := 0
    for i, v := range fill {
        if v == 1 {
            sum += (i - left) / 2 - 1
            left = i
        }
    }
    return sum >= n
}
// 思路2
func canPlaceFlowers(flowerbed []int, n int) bool {
    size := len(flowerbed)
    for i:= range flowerbed {
        if flowerbed[i] == 1 { continue }
        if i > 0 && flowerbed[i-1] == 1 { continue }
        if i + 1 < size && flowerbed[i+1] == 1 { continue }
        n--
        flowerbed[i] = 1
    }
    return n <= 0
}
#+END_SRC
