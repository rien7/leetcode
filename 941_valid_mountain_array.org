:PROPERTIES:
:ID:       ef629851-5239-4fad-8b34-7df95f1757b8
:ROAM_REFS: https://leetcode.com/problems/valid-mountain-array/submissions/
:END:
#+title: 941. Valid Mountain Array
#+filetags: :Easy:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
Given an array of integers ~arr~, return ~true~ /if and only if it is a valid mountain array/.

Recall that arr is a mountain array if and only if:

- ~arr.length >= 3~
- There exists some ~i~ with ~0 < i < arr.length - 1~ such that:
    - ~arr[0] < arr[1] < ... < arr[i - 1] < arr[i]~
    - ~arr[i] > arr[i + 1] > ... > arr[arr.length - 1]~

[[https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png]]

*Example 1:*

#+BEGIN_SRC
Input: arr = [2,1]
Output: false
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: arr = [3,5,5]
Output: false
#+END_SRC

Example 3:

#+BEGIN_SRC
Input: arr = [0,3,2,1]
Output: true
#+END_SRC

*Constraints:*

- ~1 <= arr.length <= 10^{4}~
- ~0 <= arr[i] <= 10^{4}~

* 思路
本题也是比较的简单, 需要注意几个边界条件:
1. 长度至少为3
2. 必须有上坡和下坡
3. 必须单调递增/减

一开始我的想法是拿两个下标从两边往中间移动, 判断最终的结果是否 ~i==j~. 但发现这样子有点多余, 其实可以用一个变量遍历整个数组, 在不同阶段进行相应的判断即可.

* 代码
#+BEGIN_SRC go
func validMountainArray(arr []int) bool {
    length := len(arr)
    if length < 3 { return false }
    i := 0
    for i + 1 < length && arr[i] < arr[i+1] { i++ }
    if i == 0 || i == length - 1 { return false }
    for i + 1 < length && arr[i] > arr[i+1] { i++ }
    return i == length - 1
}
#+END_SRC
