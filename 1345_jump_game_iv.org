:PROPERTIES:
:ID:       85bedc28-e7f0-4291-ae69-3c003c13572d
:ROAM_REFS: https://leetcode.com/problems/jump-game-iv/
:END:
#+title: 1345. Jump Game IV
#+filetags: :Hard:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
Given an array ofintegers ~arr~, you are initially positioned at the first index of the array.

In one step you can jump from index ~i~ to index:

- ~i + 1~ where:~i + 1 < arr.length~.
- ~i - 1~ where:~i - 1 >= 0~.
- ~j~ where: ~arr[i] == arr[j]~ and ~i != j~.

Return /the minimum number of steps/ to reach the *last index* of the array.

Notice that you can not jump outside of the array at any time.

*Example 1:*

#+BEGIN_SRC
Input: arr = [100,-23,-23,404,100,23,23,23,3,404]
Output: 3
Explanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: arr = [7]
Output: 0
Explanation: Start index is the last index. You do not need to jump.
#+END_SRC

Example 3:

#+BEGIN_SRC
Input: arr = [7,6,9,6,9,6,9,7]
Output: 1
Explanation: You can jump directly from index 0 to index 7 which is last index of the array.
#+END_SRC

*Constraints:*

- ~1 <= arr.length <= 5 * 10^{4}~
- ~-10^{8} <= arr[i] <= 10^{8}~

* 思路
本题的思路不难, 但是要捋顺就非常的困难

需要学习如何判断是否可以使用动态规划来做, 以及如何清晰的使用动态规划来做.

** 思路1
一开始我的想法是使用 动态规划 来做, =dp= 的含义为每一个下标到最后一个下标的最短距离.

但是状态转移方程并不好写, 因为 *同样的数可以跳转* 以及 *并不是单方向移动* 的缘故, 它并不能像 爬楼梯 一样简单的将状态方程写出来, 如果硬要写, 还需要记录哪一个下标已被访问, 防止重复访问同一个值.

** 思路2
正如我代码前写的注释一样, 其实这道题更适合使用 [[id:a1949000-3197-4508-902e-5e26a7877e1e][BFS]] 来做, 每一层都将其左右以及相同数字的 *未被访问的* 值放入下一层来访问

* 代码
#+BEGIN_SRC go
// dp[9] = 0
// dp[8] = 1; dp[3] = 1
// dp[7] = 2; dp[2] = 2; dp[4] = 2
// dp[6] = 3; dp[5] = 3; dp[1] = 3; dp[0] = 3
​
func minJumps(arr []int) int {
    length := len(arr)
    queue := make([]int, 0)
    visited := make([]bool , length)

    hash := make(map[int][]int, 0)
    for k, v := range arr {
        hash[v] = append(hash[v], k)
    }

    step := -1
    queue = append(queue, length-1)
    visited[length-1] = true

    for len(queue) > 0 {
        step++
        next := make([]int, 0)
        for _, i := range queue {
            if i == 0 { return step }
            if i-1 >= 0 && !visited[i-1] {
                next = append(next, i-1)
                visited[i-1] = true
            }
            if i+1 <= length-1 && !visited[i+1] {
                next = append(next, i+1)
                visited[i+1] = true
            }
            for _, k := range hash[arr[i]] {
                if visited[k] { continue }
                next = append(next, k)
                visited[k] = true
            }
            hash[arr[i]] = nil
        }
        queue = queue[:0]
        queue = append(queue, next...)
    }
    return step
}
#+END_SRC
