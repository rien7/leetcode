:PROPERTIES:
:ID:       8fa56d1d-b2bc-47b6-becc-2a52efbd52d6
:ROAM_REFS: https://leetcode.com/problems/remove-k-digits/submissions/
:END:
#+title: 402. Remove K Digits
#+filetags: :Medium:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
Given string num representing a non-negative integer ~num~, and an integer ~k~, return /the smallest possible integer after removing/ ~k~ /digits from/ ~num~.

*Example 1:*

#+BEGIN_SRC
Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
#+END_SRC

Example 3:

#+BEGIN_SRC
Input: num = "10", k = 2
Output: "0"
Explanation: Remove all the digits from the number and it is left with nothing which is 0.
#+END_SRC

*Constraints:*

- ~1 <= k <= num.length <= 10^{5}~
- ~num~ consists of only digits.
- ~num~ does not have any leading zeros except for the zero itself.

* 思路
本题的处理方法为: 维护一个单调递增的序列, 保证现在的数字最小

并且本题的边界条件有: ~k==len(num)~, ~k != 0 && len(arr) > 0~, ~len(arr) > 0 && arr[0] == '0'~

* 代码
#+BEGIN_SRC go
func removeKdigits(num string, k int) string {
    if k == len(num) { return "0" }
    arr := make([]byte, 0)
    for i := range num {
        cur := num[i]
        for len(arr) > 0 && k > 0 && arr[len(arr)-1] > cur {
            arr = arr[:len(arr)-1]
            k--
        }
        arr = append(arr, cur)
    }
    for k != 0 && len(arr) > 0 {
        arr = arr[:len(arr)-1]
        k--
    }
    for len(arr) > 0 && arr[0] == '0' {
        arr = arr[1:]
    }
    if len(arr) == 0 { return "0" }
    return string(arr)
}
#+END_SRC
