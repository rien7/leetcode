:PROPERTIES:
:ID:       a471c07d-a5ba-4928-a1e2-59ec0d614e11
:ROAM_REFS: https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/
:END:
#+title: 211. Design Add and Search Words Data Structure
#+filetags: :Medium:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
Design a data structure that supports adding new words and finding if a string matches any previously added string.

Implement the ~WordDictionary~ class:

- ~WordDictionary()~ Initializes the object.
- ~void addWord(word)~ Adds ~word~ to the data structure, it can be matched later.
- ~bool search(word)~ Returns ~true~ if there is any string in the data structure that matches ~word~or ~false~ otherwise. ~word~ may contain dots ~'.'~ where dots can be matched with any letter.

*Example:*

#+BEGIN_SRC
Input
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
Output
[null,null,null,null,false,true,true,true]

Explanation
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True
#+END_SRC

*Constraints:*

- ~1 <= word.length <= 500~
- ~word~ in ~addWord~ consists lower-case English letters.
- ~word~ in ~search~ consist of ~'.'~ or lower-case English letters.
- At most ~50000~calls will be made to ~addWord~and ~search~.

* 思路
本题的主要问题是用什么方式存储单词, 以及如何应对 "."

下面这一种方法的主要思路为: 跳过 ".", 比较剩余部分是否相等(前提是长度相等)

这种方法比较好, 因为它巧妙的避免了 "." 的问题

** 其他方法
我的原本思路是使用[[id:f726cb07-4eb9-4f05-8e62-c0986112e017][字典树]], 可能是受之前题目的影响, 认为两两比较的字符用字典树会比较方便.

但是实际使用下来体验并不好, 一是相较于按长度比较的方法来说比较的复杂, 而是 "." 的存在使得树的搜索工作变得十分困难, 不仅需要用递归来做栈, 还需要判断最终是否到达末尾.

我对于字典树的运用领域还不是特别的清楚.

* 代码
#+BEGIN_SRC go
type WordDictionary struct {
    m map[int][]string
}
​
​
func Constructor() WordDictionary {
    return WordDictionary{
        m: make(map[int][]string, 0),
    }
}
​
​
func (this *WordDictionary) AddWord(word string) {
    n := len(word)
    this.m[n] = append(this.m[n], word)
}
​
​
func (this *WordDictionary) Search(word string) bool {
    for _, w := range this.m[len(word)] {
        if match(w, word) {
            return true
        }
    }
    return false
}
​
func match(w, word string) bool {
    for i := 0; i < len(w); i++ {
        if word[i] != 46 && word[i] != w[i] {
            return false
        }
    }
    return true
}
​
​
/**
 * Your WordDictionary object will be instantiated and called as such:
 * obj := Constructor();
 * obj.AddWord(word);
 * param_2 := obj.Search(word);
 */
#+END_SRC
