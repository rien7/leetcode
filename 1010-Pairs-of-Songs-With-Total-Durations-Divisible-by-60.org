:PROPERTIES:
:ID:       104eb5fa-bfd5-454c-a710-88866a3cab6a
:ROAM_REFS: https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/
:END:
#+TITLE: 1010. Pairs of Songs With Total Durations Divisible by 60
#+filetags: :Medium:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
You are given a list of songs where the =ith= song has a duration of =time[i]= seconds.

Return the number of pairs of songs for which their total duration in seconds is divisible by =60=. Formally, we want the number of indices =i=, =j= such that =i < j= with ~(time[i] + time[j]) % 60 == 0~.

Example 1:
#+BEGIN_SRC
Input: time = [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60
#+END_SRC
Example 2:
#+BEGIN_SRC
Input: time = [60,60,60]
Output: 3
Explanation: All three pairs have a total duration of 120, which is divisible by 60.
#+END_SRC


Constraints:
- ~1 <= time.length <= 6 * 104~
- ~1 <= time[i] <= 500~

* 思路
本题的想法比较简单, 一是暴力破解, 设置两个循环遍历整个数组. 但这么做的时间复杂度来到了 =O(n^2)=, 不是最优解.

可以注意到, 两个数要加起来的和为 60 的倍数, 那么可以使用 ~time[i] % 60~ 的方法, 即[[id:048d8e50-98bb-4017-9d39-ae1fa5ce09af][哈希表]]的方法, 只留下真正能够影响结果的部分. 仔细一想即可知道, 假设余数为 5 的数字要和其他数字的和为 60 的倍数, 那么这个数的余数必为 55, 这两组数可能发生的组合个数为 ~i * j~.

还需要留意两个特殊情况, 即 0 和 30. 这两组数都只能和自身组合, 并且由于不能重复以及不能和自身组合, 因此这两组数的组合个数都是 ~i * (i-1) / 2~ (等差数列求和)

* 代码
#+begin_src go
func numPairsDivisibleBy60(time []int) int {
    count := make([]int, 60)
    for _, t := range time {
        count[t % 60]++
    }
    sum := 0
    for i := 1; i < 30; i ++ {
        sum += count[i] * count[60-i]
    }
    sum += count[0] * (count[0]-1) / 2
    sum += count[30] * (count[30]-1) / 2
    return sum
}
#+end_src
