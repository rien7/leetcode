:PROPERTIES:
:ID:       45dacc9a-2bdc-4eef-8cb6-c735ada36b06
:ROAM_REFS: https://leetcode.com/problems/burst-balloons/
:END:
#+TITLE: 312. Burst Balloons
#+filetags: :Hard:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
You are given =n= balloons, indexed from =0= to =n - 1=. Each balloon is painted with a number on it represented by an array =nums=. You are asked to burst all the balloons.

If you burst the =ith= balloon, you will get =nums[i - 1] * nums[i] * nums[i + 1]= coins. If =i - 1= or =i + 1= goes out of bounds of the array, then treat it as if there is a balloon with a =1= painted on it.

Return /the maximum coins you can collect by bursting the balloons wisely/.

Example 1:
#+BEGIN_SRC
Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
#+END_SRC
Example 2:
#+BEGIN_SRC
Input: nums = [1,5]
Output: 10
#+END_SRC

Constraints:
- ~n == nums.length~
- ~1 <= n <= 500~
- ~0 <= nums[i] <= 100~


* 思路
本题的问题在于: *如何获得最大的硬币数*, 这个问题显然需要使用[[id:a079d01f-7acf-4c34-bcbc-0fe0f71d09f7][动态规划]]来解决问题, 但是如何设置『状态转移方程』就是这个问题的难点.

** 想法1
从题目可以知道, 如果击破的气球为边缘气球(即一边没有其他气球), 这用 =1= 来填充没有气球的那一边.

例如: [1,2,3,4] 中如果击破 4, 那么获得的硬币为 =3 * 4 * 1 = 12=, 最后的 =1= 就是填充右边没有气球的部分.

那么可以在数组两边填充 1 来减少后续的判断步骤, 即 [1,2,3,4] => [1,1,2,3,4,1]

#+begin_src go
nums := append([]int{1}, append(nums, 1)...)
#+end_src

** 想法2
找到将 *大问题* 分解为 *相似的小问题* 即找到了状态转移方程

在本题中, 大问题是如何在击破所有气球后获得的硬币数最多.

分解为小问题即: 剩余最后一个气球的情况下, 击破哪个气球后获得的硬币数最多.

在这种情况下, =硬币数 = 击破气球获得的硬币 + 气球左边区间获得的最大硬币数 + 气球右边区间获得的最大硬币数=

这样就把问题化成了两个子问题, 即

#+begin_src go
dp[left][right] = max(dp[left][right], nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] + dp[k+1][right])
#+end_src

** 想法3
找到状态转移方程以后, 最后一步即定义 =dp= 所代表的含义.

根据状态转移方程的意义, 这里定义 =dp= 为一个二维数组 ~var dp [][]int~, 代表这一个区间中获得的最大的硬币数

* 代码

#+begin_src go
func maxCoins(nums []int) int {
    n := len(nums)
    nums = append([]int{1}, append(nums, 1)...)
    dp := make([][]int, n+2)
    for i := range dp {
        dp[i] = make([]int, n+2)
    }
    for window := 1; window <= n; window++ {
        for left := 1; left <= n - window + 1; left++ {
            right := left + window - 1
            for k := left; k <= right; k++ {
                coins := nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] + dp[k+1][right]
                if dp[left][right] < coins {
                    dp[left][right] = coins
                }
            }
        }
    }
    return dp[1][n]
}
#+end_src
