:PROPERTIES:
:ID:       ad373bb7-f91b-44b7-918a-45529fe43027
:ROAM_REFS: https://leetcode.com/problems/subsets/submissions/
:END:
#+title: 78. Subsets
#+filetags: :Medium:

* [[id:2b2e3e1f-924b-43fe-a7f8-a1eb6482d2f2][问题]]
Given an integer array ~nums~ of *unique* elements, return /all possible subsets (the power set)/.

The solution set *must not* contain duplicate subsets. Return the solution in *any order*.

*Example 1:*

#+BEGIN_SRC
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: nums = [0]
Output: [[],[0]]
#+END_SRC

*Constraints:*

- ~1 <= nums.length <= 10~
- ~-10 <= nums[i] <= 10~
- All the numbers of ~nums~ are *unique*.

* 思路
发现了一种很强的方法: 这个问题的核心在于如何找到所有的选取方式, 这种方法和数字的字节表示方法类似.

例如: [1,2,3] 的数组的选取方式其实就是 [0, 8) 的字节表示.
#+begin_src
0 ==> 000 ==> []
1 ==> 001 ==> [1]
2 ==> 010 ==> [2]
3 ==> 011 ==> [1,2]
4 ==> 100 ==> [3]
5 ==> 101 ==> [1,3]
6 ==> 110 ==> [2,3]
7 ==> 111 ==> [1,2,3]
#+end_src

* 代码
#+BEGIN_SRC go
func subsets(nums []int) [][]int {
    n := len(nums)
    numBit := 1 << n
    res := make([][]int, 0)
    for i := 0; i < numBit; i++ {
        r := make([]int, 0)
        for j := range nums {
            if (i >> j) & 1 == 1 {
                r = append(r, nums[j])
            }
        }
        res = append(res, r)
    }
    return res
}
#+END_SRC
