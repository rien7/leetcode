:PROPERTIES:
:ID:       ac0cd3fd-3c6a-46e7-b36b-71b1d9f2147a
:ROAM_REFS: https://leetcode.com/problems/cherry-pickup-ii/
:END:
#+title: 1463. Cherry Pickup II
#+filetags: :Hard:

* 问题
You are given a ~rows x cols~ matrix ~grid~ representing a field of cherries where ~grid[i][j]~ represents the number of cherries that you can collect from the ~(i, j)~ cell.

You have two robots that can collect cherries for you:

- *Robot #1* is located at the *top-left corner* ~(0, 0)~, and
- *Robot #2* is located at the *top-right corner* ~(0, cols - 1)~.

Return /the maximum number of cherries collection using both robots by following the rules below/:

- From a cell ~(i, j)~, robots can move to cell ~(i + 1, j - 1)~, ~(i + 1, j)~, or ~(i + 1, j + 1)~.
- When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.
- When both robots stay in the same cell, only one takes the cherries.
- Both robots cannot move outside of the grid at any moment.
- Both robots should reach the bottom row in ~grid~.

*Example 1:*

[[https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png]]
#+BEGIN_SRC
Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
Output: 24
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.
Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.
Total of cherries: 12 + 12 = 24.
#+END_SRC

Example 2:

[[https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png]]
#+BEGIN_SRC
Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
Output: 28
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.
Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.
Total of cherries: 17 + 11 = 28.
#+END_SRC

*Constraints:*

- ~rows == grid.length~
- ~cols == grid[i].length~
- ~2 <= rows, cols <= 70~
- ~0 <= grid[i][j] <= 100~

* 思路
本题依然是使用[[id:a079d01f-7acf-4c34-bcbc-0fe0f71d09f7][动态规划]], 但稍微不同的是, 状态转移方程不再是二维而是三维, 来保证两个机器人一起运动.

* 代码
#+BEGIN_SRC go
func cherryPickup(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])
    dp := make([][][]int, m)
    for i := 0; i < m; i++ {
        dp[i] = make([][]int, n)
        for j := 0; j < n; j++ {
            dp[i][j] = make([]int, n)
            for k := 0; k < n; k++ {
                dp[i][j][k] = -1
            }
        }
    }
    return dfs(0, 0, n - 1, grid, dp)
}
​
func dfs(row, col1, col2 int, grid [][]int, dp [][][]int) int {
    if col1 < 0 || col2 < 0 || col1 >= len(grid[0]) || col2 >= len(grid[0]) {
        return 0
    }
    if res := dp[row][col1][col2]; res != -1 {
        return res
    }
    res := 0
    res += grid[row][col1]
    if col1 != col2 {
        res += grid[row][col2]
    }
    if row != len(grid) - 1 {
        max := 0
        for i := col1-1; i <= col1+1; i++ {
            for j := col2-1; j <= col2+1; j++ {
                max = Max(max, dfs(row+1, i, j, grid, dp))
            }
        }
        res += max
    }
    dp[row][col1][col2] = res
    return res
}
​
func Max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
#+END_SRC
