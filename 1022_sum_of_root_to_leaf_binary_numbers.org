:PROPERTIES:
:ID:       5ecd3a99-cef8-485a-83d1-5d24eadb26ff
:ROAM_REFS: https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
:END:
#+title: 1022. Sum of Root To Leaf Binary Numbers
#+filetags: :Easy:

* 问题
You are given the ~root~ of a binary tree where each node has a value ~0~ or ~1~. Each root-to-leaf path represents a binary number starting with the most significant bit.

- For example, if the path is ~0 -> 1 -> 1 -> 0 -> 1~, then this could represent ~01101~ in binary, which is ~13~.

For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return /the sum of these numbers/.

The test cases are generated so that the answer fits in a *32-bits* integer.

*Example 1:*

[[https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png]]
#+BEGIN_SRC
Input: root = [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
#+END_SRC

Example 2:

#+BEGIN_SRC
Input: root = [0]
Output: 0
#+END_SRC

*Constraints:*

- The number of nodes in the tree is in the range ~[1, 1000]~.
- ~Node.val~ is ~0~ or ~1~.

* 思路
本题需要注意的地方是边界条件, 即什么时候才应该将结果相加

仔细思考, 是在叶子节点(也就是左右子树为 =nil=)的时候才将结果相加

* 代码
#+BEGIN_SRC go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func sumRootToLeaf(root *TreeNode) int {
    sum := 0
    dfs(root, 0, &sum)
    return sum
}
​
func dfs(cur *TreeNode, num int, sum *int) {
    if cur == nil {
        return
    }
    num = num << 1 + cur.Val
    if cur.Left == nil && cur.Right == nil {
        *(sum) += num
    }
    dfs(cur.Left, num, sum)
    dfs(cur.Right, num, sum)
}
#+END_SRC
